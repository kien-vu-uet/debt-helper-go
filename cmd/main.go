package main

import (
	"errors"
	"fmt" // Added for DSN construction
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/mysql"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	route "github.com/kien-vu-uet/debt-helper-go/api/route"
	"github.com/kien-vu-uet/debt-helper-go/bootstrap"
	_ "github.com/kien-vu-uet/debt-helper-go/docs" // docs is generated by Swag CLI, you have to import it.
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

// @title Debt Helper API
// @version 1.0
// @description This is a sample server for a debt helper application.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1
func main() {
	// Initialize bootstrap app, env, and logger first
	app := bootstrap.App()
	env := app.Env
	logger := app.Logger // Use this logger instance throughout

	// Construct DSN from environment variables
	// TODO: Replace placeholder env field names (DBUsername, DBPassword, etc.)
	// with the actual field names from your bootstrap/env.go or equivalent configuration.
	dsn := fmt.Sprintf("mysql://%s:%s@tcp(%s:%s)/%s?parseTime=true",
		env.DBUser, // Example: env.DBUser, env.DatabaseUsername
		env.DBPass, // Example: env.DBPass, env.DatabasePassword
		env.DBHost, // Example: env.DatabaseHost
		env.DBPort, // Example: env.DatabasePort
		env.DBName, // Example: env.DatabaseName
	)

	logger.Info("Attempting to run database migrations from file://db/migrations")

	m, err := migrate.New(
		"file://db/migrations",
		dsn, // Use dynamic DSN
	)
	if err != nil {
		logger.ErrorLogger.Fatalf("Migration initialization failed: %v", err) // Use initialized app logger's ErrorLogger
	}

	if err := m.Up(); err != nil {
		if errors.As(err, &migrate.ErrDirty{}) {
			logger.ErrorLogger.Println("Database is in a dirty state. Attempting to force clean...")

			// Force the migration to the last known good version
			// Replace '1' with the appropriate version number
			if forceErr := m.Force(1); forceErr != nil {
				logger.ErrorLogger.Fatalf("Failed to force migration version: %v", forceErr)
			}

			// Retry the migration after forcing
			if retryErr := m.Up(); retryErr != nil && retryErr != migrate.ErrNoChange {
				logger.ErrorLogger.Fatalf("Migration failed after forcing version: %v", retryErr)
			}

			logger.InfoLogger.Println("Migration completed successfully after forcing version.")
		} else if err != migrate.ErrNoChange {
			logger.ErrorLogger.Fatalf("Migration failed: %v", err)
		} else {
			logger.InfoLogger.Println("No new migrations to apply.")
		}
	} else {
		logger.ErrorLogger.Println("Migrations applied successfully.")
	}

	logger.Info("Starting the application") // Log application start

	db := app.DB // Now this is *gorm.DB
	defer func() {
		logger.Info("Closing database connection") // Log DB connection close
		app.CloseDBConnection()
	}()

	timeout := time.Duration(env.ContextTimeout) * time.Second

	ginEngine := gin.Default()

	// Swagger endpoint
	ginEngine.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Pass db (*gorm.DB) to route.Setup
	route.Setup(env, timeout, db, ginEngine) // db is now *gorm.DB

	logger.Info("Starting server on " + env.ServerAddress) // Log server start
	ginEngine.Run(env.ServerAddress)
}
